# 斐波那契数列 #
## 题目描述 ##
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

By [zouwx2cs](https://github.com/zouwx2cs/)

### 迭代解法 ###
- **解题思路**

	a[0] = 0, a[1] = 1, 迭代到 a[n] = a[n-1] + a[n-2]
	
- **时间复杂度**

	**O(n)**， 迭代n次 

- **空间复杂度**

	**O(n)**， 需要n个空间存储数列a[]
	
- **提交版本**
	
Source Name | Language | Time | Memory | Contributor
---|---|---|---|---
[Solution2.cpp]() | c++11 | - | - | zouwx2cs

### 节约空间的迭代解法 ###
- **解题思路**

    由于计算a[n]仅仅需要前面连个元素，因此可以进一步把算法需要的额外空间压缩到常数个，变成原地算法
	a\_n2 = 0, a\_n2 = 1 ;
	for (n-1次)
	{
	  a\_n = a\_n1 + a\_n2 ;
	  swap(a\_n2, a\_n1) ;
	  swap(a\_n1, a\_n) ;
	}
	return a\_n ;
	
	当然可以用位操作优化代码，避免swap
	for (n-1次)
	    a[n&1] = a[n&1] + a[!(n&1)]
	return a[n&1] ;
	
- **时间复杂度**

	**O(n)**， 迭代n次 

- **空间复杂度**

	**O(1)**， 常数空间，原地算法
	
- **提交版本**
	
Source Name | Language | Time | Memory | Contributor
---|---|---|---|---
[Solution3.cpp]() | c++11 | - | - | zouwx2cs

### 递归解法 ###
- **解题思路**

    递推方程： f(n) = f(n-1) + f(n-2) ;
    递归出口： f(0) = 0, f(1) = 1 ;
	
- **时间复杂度**

	**O(n^2)**， 包含大量重复计算复杂度是n方级 

- **空间复杂度**

	**O(n^2)**， 递归调用栈消耗了一些空间，由于有重复计算是n方级
	
- **提交版本**
	
Source Name | Language | Time | Memory | Contributor
---|---|---|---|---
[Solution4.cpp]() | c++11 | - | - | zouwx2cs

### 记忆化递归解法 ###
- **解题思路**

    既然普通的递归解法产生大量的重复计算，如果已经计算过的f(x) 把结果保存不就减少了计算么？
    用一个数组记忆计算结果，如果f(x)已经计算过了，直接返回a[x]
	
- **时间复杂度**

	**O(n)**， 由于计算过的记忆下了，只要n次 

- **空间复杂度**

	**O(n)**， 递归调用栈消耗了线性数量级，记忆数组计算了n数量级的空间
	
- **提交版本**
	
Source Name | Language | Time | Memory | Contributor
---|---|---|---|---
[Solution5.cpp]() | c++11 | - | - | zouwx2cs
